# ================================================================
한글 프로그래밍 언어 문법 명세서 v20.0.0
> v20.0.0 변경: 온톨로지 문법 — 온톨로지 블록/개념/속성/관계/질의/추론 6종 구문 (섹션 33)
> v19.0.0 변경: 온디바이스 AI — AI모델/TinyML/연합학습 블록 + AI불러오기/추론/학습단계/저장 (섹션 32)
> v18.0.0 변경: 안전 규격 — 워치독/결함허용 블록 + 페일세이프/긴급정지/경보발령 (섹션 31)
> v17.0.0 변경: 산업/임베디드 — 타이머/ROS2 블록 + GPIO/I2C/SPI/UART/Modbus/CAN/MQTT 22종 (섹션 30)
> v16.0.0 변경: 내장함수 31종 추가 — 수학/역삼각/글자/배열/시간/시스템/JSON (섹션 29 확장)
> v13.0.0 변경: 자동미분(Autograd) 엔진 — GradFn + 역전파 10종 + 역전파()/기울기초기화() 내장함수 (섹션 29)
> v12.0.0 변경: 텐서(Tensor) 자료형 — N차원 텐서 + 12종 내장함수 (섹션 28)
> v11.0.0 변경: 파일 분리 — kcodegen 4분할 / kcodegen_llvm 4분할 (Unity Build)
> v10.0.0 변경: 내장함수 전체 완성 — 통계/활성함수/파일/글자 LLVM IR 완전 구현
> v8.2.0 변경: 가속기 GPU(CUDA)/NPU(ONNX)/CPU(OpenMP) 블록 추가
> v8.0.0 변경: 글자 내장 함수 21종 완전 구현
> v7.0.0 변경: 글자 함수 5종 추가 (자르기/분할/합치기/포함/위치)
> v6.2.0 변경: 객체(CLASS) LLVM IR 완전 구현
> v6.0.0 변경: 인터럽트 시스템 3종 (A:OS시그널/B:하드웨어간섭/C:행사) 전체 구문 추가
> v5.0.0 변경: 계약 시스템 v2.0 구현 완료 — 헌법/법률/규정/법령/법위반 5계층 문법 확정
> v4.2.0 변경: 파일 내장 함수 16종 추가 (파일열기~파일이동)
> v3.8.0 변경: 통계 함수 13종 + AI 활성함수 3종 + 호감도 함수(관계심리) 추가
> v2.0.0 변경: 글자(char) ↔ 문자(string) 자료형 명칭 교체 — 현재 명세 반영

-----

## 1. 파일 확장자

-----

소스파일   : .han
컴파일결과 : .exe , .apk , .ipa
헤더      : .hg

-----

## 2. 주석

-----

한줄 주석  : // 이것은 주석입니다
여러줄 주석: /*
여러 줄에 걸친
주석입니다
*/

-----

## 3. 자료형

-----

### 기본 자료형

정수        - 소수점 없는 숫자           예) 1, -5, 100
실수        - 소수점 있는 숫자           예) 3.14, -0.5
문자        - 문자 하나 (char)           예) '가', 'A'       ← v2.0 변경
글자        - 문자 여러 개 (string)      예) "안녕하세요"    ← v2.0 변경
논리        - 참 또는 거짓               예) 참, 거짓
없음        - 값이 없음 (null)
2진         - 2진법 리터럴               예) 0b1010
8진         - 8진법 리터럴               예) 0o17
16진        - 16진법 리터럴              예) 0xFF

### 확장 자료형

행렬        - 다차원 행렬 (matrix)
텐서        - N차원 밀집 텐서 (tensor, double 정밀도) — v12.0.0
              속성: .형태 / .차원 / .원소수 / .기울기 / .미분추적
사진        - 이미지 데이터 타입
그림        - 캔버스/렌더링 타입
함수형      - 일급 함수 타입

### 자료구조 타입

배열        - 동적 배열 (array)
사전        - 키-값 쌍 (dictionary)
목록        - 구조체 정의 (struct)
객체        - 클래스 (class)
열거        - 열거형 (enum)
틀          - 인터페이스 (interface)

-----

## 4. 변수 선언

-----

형식: [자료형] [변수이름] = [값]

예)
정수 나이 = 25
실수 키 = 175.5
글자 이름 = "홍길동"
논리 성인여부 = 참
문자 첫문자 = '홍'

상수 선언 (값 변경 불가):
고정 정수 최대값 = 100

-----

## 5. 연산자

-----

### 산술 연산자

+   더하기
-   빼기
*   곱하기
/   나누기
%   나머지
**  거듭제곱

### 비교 연산자

==  같다
!=  다르다
>   크다
<   작다
>=  크거나같다
<=  작거나같다

### 논리 연산자

그리고   (AND)
또는     (OR)
아니다   (NOT)

예)
만약 나이 >= 18 그리고 나이 <= 65:

### 비트 연산자

&   비트 AND
|   비트 OR
^   비트 XOR
~   비트 NOT
<<  왼쪽 시프트
>>  오른쪽 시프트

### 대입 연산자

=   기본 대입
+=  더하기 대입
-=  빼기 대입
*=  곱하기 대입
/=  나누기 대입
%=  나머지 대입

-----

## 6. 조건문

-----

형식:
만약 [조건]:
    [실행내용]
아니면 만약 [조건]:
    [실행내용]
아니면:
    [실행내용]

예)
만약 점수 >= 90:
    출력("A등급")
아니면 만약 점수 >= 80:
    출력("B등급")
아니면:
    출력("C등급 이하")

-----

## 7. 반복문

-----

### 횟수 반복

반복 [변수] 부터 [시작] 까지 [끝]:
    [실행내용]

```
예)
반복 i 부터 1 까지 10:
    출력(i)
```

### 조건 반복

동안 [조건]:
    [실행내용]

```
예)
동안 횟수 < 10:
    횟수 = 횟수 + 1
```

### 목록 순회

각각 [변수] 안에 [목록]:
    [실행내용]

```
예)
각각 이름 안에 이름목록:
    출력(이름)
```

### 반복 제어

멈춤    - 반복 즉시 종료 (break)
건너뜀  - 다음 반복으로 이동 (continue)

-----

## 8. 분기문 (Select)

-----

선택 [조건]
    경우 [일치하는 값]:
        [내용]
    그외:
        [내용]

```
예)
선택 이름
    경우 "홍길동":
        출력("홍길동")
    경우 "아버지":
        출력("아버지")
    그외:
        출력("일치하는 이름 없음")
```

-----

## 9. 강제 이동 (goto)

-----

이동 [이름]

이름:

-----

## 10. 함수

-----

### 반환값이 있는 함수

형식:
함수 [함수이름]([매개변수]):
    [실행내용]
    반환 [값]

예)
함수 더하기(정수 가, 정수 나):
    반환 가 + 나

### 반환값이 없는 함수 (void)

형식:
정의 [함수이름]([매개변수]):
    [실행내용]
    끝냄

예)
정의 인사(글자 이름):
    출력("안녕하세요, " + 이름)
    끝냄

### 가변 매개변수

형식: [자료형] [이름]...

예)
함수 합계(정수 값...):
    반환 값

### 람다 (익명 함수)

형식: ([매개변수]) => [표현식]

예)
함수형 두배 = (정수 x) => x * 2
함수형 덧셈 = (정수 가, 정수 나) => 가 + 나
함수형 빈람다 = () => 42

-----

## 11. 배열

-----

### 배열 리터럴

배열 이름 = [값1, 값2, 값3]

예)
배열 숫자들 = [1, 2, 3, 4, 5]
배열 이름들 = ["홍길동", "김철수"]

### 인덱스 접근

배열이름[인덱스]

예)
출력(숫자들[0])     // 첫 번째 원소
숫자들[1] = 99      // 두 번째 원소 수정

### 배열 멤버

배열이름.길이       // 배열 원소 개수

-----

## 12. 사전

-----

### 사전 리터럴

사전 이름 = {키1: 값1, 키2: 값2}

예)
사전 정보 = {"이름": "홍길동", "나이": 25}

### 사전 접근

정보["이름"]
정보.이름

-----

## 13. 객체 (클래스)

-----

### 클래스 선언

객체 [이름] [이어받기 부모클래스]:
    [속성 및 메서드]

예)
객체 사람:
    글자 이름
    정수 나이

    함수 생성(글자 이름, 정수 나이):
        자신.이름 = 이름
        자신.나이 = 나이

    함수 인사():
        출력("안녕하세요, " + 자신.이름)

### 상속

객체 학생 이어받기 사람:
    글자 학교

    함수 생성(글자 이름, 정수 나이, 글자 학교):
        부모.생성(이름, 나이)
        자신.학교 = 학교

### 멤버 접근

객체이름.속성
객체이름.메서드()
자신        // 현재 객체 (this/self)
부모        // 부모 클래스 (super)
생성        // 생성자 (constructor)

-----

## 14. 예외 처리

-----

시도:
    [실행 내용]
실패시:
    [오류 처리]
    // '오류' 변수로 오류 메시지 전달
항상:
    [항상 실행]

예)
시도:
    출력(10 / 0)
실패시:
    출력("오류 발생: " + 오류)
항상:
    출력("정리 완료")

### 오류 발생

오류([오류 메시지])

예)
오류("잘못된 입력입니다")

-----

## 15. 모듈 가져오기

-----

형식:
가짐 [모듈이름]
가짐 [모듈이름] 로부터 [이름1, 이름2, ...]
#포함 [파일명]

예)
가짐 수학
가짐 파일시스템 로부터 읽기, 쓰기

// 외부 파일 포함 (v6.1.0 — 8종 확장자 지원)
#포함 "유틸.han"           // Kcode 소스 — 파싱 후 현재 환경 실행
#포함 "헤더.hg"            // Kcode 헤더
#포함 "도구.c"             // C 파일 → #include "도구.c" 생성
#포함 "연산.cpp"           // C++ 파일 → #ifdef __cplusplus #include 생성
#포함 "분석.py"            // Python — python3 실행 후 stdout 반환
#포함 "처리.js"            // JavaScript — node 실행 후 stdout 반환
#포함 "변환.ts"            // TypeScript — ts-node 실행 후 stdout 반환
#포함 "모듈.java"          // Java — javac 컴파일 후 java 실행

### 가짐(import) 내장 모듈 → C 헤더 매핑

| Kcode 모듈   | C 헤더                                    |
|-------------|------------------------------------------|
| 수학 / 수학함수 | `<math.h>`                               |
| 파일시스템     | `<stdio.h>` + `<dirent.h>` + `<sys/stat.h>` |
| 문자열       | `<string.h>`                              |
| 시간         | `<time.h>`                                |
| 난수         | `<stdlib.h>`                              |

-----

## 16. 입출력

-----

출력([값])           // 줄바꿈 포함 출력
출력없이([값])       // 줄바꿈 없는 출력
입력([안내문자열])   // 사용자 입력 받기
파일열기([경로])     // 파일 열기

예)
출력("안녕하세요")
출력없이("로딩 중")
글자 이름 = 입력("이름을 입력하세요: ")

-----

## 17. 내장 함수

-----

| 함수명      | 설명                                   |
|-------------|----------------------------------------|
| 출력(값)    | 값을 출력하고 줄바꿈                   |
| 출력없이(값)| 값을 출력하고 줄바꿈 없음              |
| 입력(안내)  | 사용자 입력 한 줄 읽기                 |
| 길이(값)    | 문자열 또는 배열의 길이 반환           |
| 범위(끝)    | 0부터 끝까지 정수 배열 생성            |
| 범위(시작, 끝) | 시작부터 끝까지 정수 배열 생성      |
| 범위(시작, 끝, 간격) | 간격 단위 정수 배열 생성      |
| 정수(값)    | 정수로 형변환 (값은 숫자·글자·배열 가능) |
| 실수(값)    | 실수로 형변환 (값은 숫자·글자·배열 가능) |
| 글자(값)    | 문자열로 형변환                        |
| 추가(배열, 값) | 배열 끝에 값 추가                   |
| 제곱근(값)  | 제곱근 계산 (값은 숫자 또는 실수 반환) |
| 절댓값(값)  | 절댓값 계산 (값은 숫자 또는 배열)      |
| 최대(값, ...) | 최댓값 반환 — 가변 인수 또는 배열 1개 허용 |
| 최소(값, ...) | 최솟값 반환 — 가변 인수 또는 배열 1개 허용 |
| **수학 기초 (v3.7.1 / v3.8.0 확장)** | |
| 올림(값, 자릿수=0) | ceiling — 올림. 올림(3.14,1)→3.2, 올림(3.1)→4 |
| 내림(값, 자릿수=0) | floor — 내림. 내림(3.99,1)→3.9, 내림(3.9)→3   |
| 반올림(값, 자릿수=0) | 자릿수 지정 반올림. 반올림(3.456,2)→3.46, 반올림(3.4)→3 |
| 사인(값)    | sin(라디안) 반환                       |
| 코사인(값)  | cos(라디안) 반환                       |
| 탄젠트(값)  | tan(라디안) 반환                       |
| 자연로그(값)| ln(x) = log_e(x) 반환                 |
| 로그(밑, 값)| log_밑(값) 반환                       |
| 지수(값)    | e^x 반환                               |
| `파이`      | π = 3.14159... (상수)                  |
| `오일러`    | e = 2.71828... (상수)                  |
| **통계 함수 (v3.8.0 추가)** | |
| 합계(배열)  | 배열 원소의 합 반환                    |
| 평균(배열)  | 배열 원소의 산술 평균 반환             |
| 분산(배열, 표본=0) | 모분산(표본=0) 또는 표본분산(표본=1) 반환 |
| 표준편차(배열, 표본=0) | 표준편차 반환 (분산의 제곱근)  |
| 중앙값(배열) | 배열을 정렬했을 때 중앙 값 반환       |
| 최빈값(배열) | 가장 많이 나타나는 값 반환 (동점 시 첫 번째) |
| 누적합(배열) | 누적 합 배열 반환. [1,2,3]→[1.0,3.0,6.0] |
| 공분산(배열, 배열, 표본=0) | 두 배열의 공분산 반환       |
| 상관계수(배열, 배열) | 피어슨 상관계수 r 반환 (−1 ~ 1) |
| 정규화(배열) | Min-Max 정규화 → [0, 1] 범위 배열 반환 |
| 표준화(배열) | Z-score 표준화 → 평균 0, 분산 1 배열 반환 |
| 배열정렬(배열, 내림차순=0) | 정렬된 새 배열 반환. 배열정렬(arr,1) = 내림차순 |
| 배열뒤집기(배열) | 순서를 뒤집은 새 배열 반환            |
| **AI 활성함수 (v3.8.0 추가)** | |
| 시그모이드(값) | σ(x)=1/(1+e^-x) — 숫자 또는 배열 원소 각각 적용 |
| 렐루(값)    | ReLU(x)=max(0,x) — 숫자 또는 배열 원소 각각 적용 |
| 쌍곡탄젠트(값) | tanh(x) — 숫자 또는 배열 원소 각각 적용       |
| **AI / 수학 함수 (v3.6.0 추가)** | |
| 평균제곱오차(예측, 실제) | MSE = (1/N)Σ(y-ŷ)² — 회귀 손실 함수  |
| 교차엔트로피(P_star, P) | H = -ΣP*(i)logP(i) — 분류 손실 함수  |
| 소프트맥스(배열)        | yᵢ = eᵃⁱ/Σeᵃʲ — 확률 분포 변환      |
| 위치인코딩(위치, 차원수) | sin/cos 교대 인코딩 — Transformer PE |
| 등비수열합(a, r)        | 무한 등비급수 a/(1-r), \|r\|<1        |
| 등차수열합(a, d, n)     | n/2*(2a+(n-1)d) — n항까지 합          |
| 점화식값(a1, r, n)      | a1*r^(n-1) — 등비 점화식 n번째 항    |
| **관계 심리 함수 (v3.8.0 추가)** | |
| 호감도(T, S, C, R) | 기본 평균형 L = (T+S+C+R)/4 → 실수 반환 |
| 호감도(T, S, C, R, α, β, γ, δ) | 가중합형 L = αT+βS+γC+δR — 계수 직접 지정 |
| 호감도([T,S,C,R]) | 배열 평균형 — 4원소 배열 입력 |
| 호감도([T,S,C,R], [α,β,γ,δ]) | 배열 가중합형 — 두 배열 입력 |

> **호감도 변수 정의**
> - T (Trust): 신뢰 — 상대를 얼마나 믿는가
> - S (Similarity): 유사성 — 가치관·관심사의 공통점
> - C (Communication): 소통 — 대화의 질과 빈도
> - R (Reward): 행복감 — 함께 있을 때 느끼는 긍정적 감정
> - α,β,γ,δ: 개인별 가중치 (합이 1.0이면 정규화된 결과)
> - 각 인수 권장 범위: 0.0 ~ 1.0

### 호감도 함수 사용 예시

```
// ① 기본 평균형 — 네 요소를 동등하게 가중
실수 결과 = 호감도(0.8, 0.6, 0.9, 0.7)
출력(결과)   // (0.8+0.6+0.9+0.7)/4 = 0.75

// ② 가중합형 — 사람마다 다른 계수 적용
// 신뢰를 가장 중요하게 여기는 사람
실수 결과2 = 호감도(0.8, 0.6, 0.9, 0.7,  0.4, 0.2, 0.2, 0.2)
출력(결과2)  // 0.4*0.8 + 0.2*0.6 + 0.2*0.9 + 0.2*0.7 = 0.76

// ③ 배열 평균형
배열 요소 = [0.8, 0.6, 0.9, 0.7]
출력(호감도(요소))  // 0.75

// ④ 배열 가중합형 — 소통을 중요시하는 사람
배열 가중치 = [0.2, 0.2, 0.4, 0.2]
출력(호감도(요소, 가중치))  // 0.76

// ⑤ 관계 변화 시뮬레이션
배열 시간별_신뢰  = [0.3, 0.5, 0.7, 0.85]
배열 시간별_소통  = [0.5, 0.6, 0.65, 0.8]
배열 시간별_유사  = [0.4, 0.45, 0.5, 0.55]
배열 시간별_행복  = [0.4, 0.6, 0.7, 0.9]

반복 i 부터 0 까지 3:
    실수 l = 호감도(시간별_신뢰[i], 시간별_유사[i],
                   시간별_소통[i], 시간별_행복[i])
    출력("t=" + 글자(i) + " 호감도=" + 글자(l))
```

### 통계 함수 사용 예시

```
// 기술 통계
배열 점수 = [70.0, 85.0, 90.0, 60.0, 95.0]
출력(합계(점수))         // 400.0
출력(평균(점수))         // 80.0
출력(분산(점수))         // 146.0  (모분산)
출력(분산(점수, 1))      // 182.5  (표본분산)
출력(표준편차(점수))     // 12.083...
출력(중앙값(점수))       // 85.0
출력(최빈값(점수))       // 70.0 (모두 1회이므로 첫값)
출력(누적합(점수))       // [70.0, 155.0, 245.0, 305.0, 400.0]

// 최대/최소 — 배열 직접 입력 가능
출력(최대(점수))         // 95.0
출력(최소(점수))         // 60.0

// 올림/내림 자릿수 지정
출력(올림(3.14, 1))      // 3.2
출력(내림(3.99, 1))      // 3.9
출력(올림(314, -2))      // 400

// 상관 분석
배열 키  = [160.0, 170.0, 180.0]
배열 몸무게 = [55.0, 68.0, 80.0]
출력(상관계수(키, 몸무게))  // 1.0 (완전 양의 상관)
출력(공분산(키, 몸무게))    // 83.333...

// 데이터 전처리
출력(정규화(점수))       // [0.143, 0.714, 0.857, 0.0, 1.0]
출력(표준화(점수))       // Z-score 배열
출력(배열정렬(점수))     // [60.0, 70.0, 85.0, 90.0, 95.0]
출력(배열정렬(점수, 1))  // [95.0, 90.0, 85.0, 70.0, 60.0] 내림차순
출력(배열뒤집기(점수))   // [95.0, 60.0, 90.0, 85.0, 70.0]
```

### AI 활성함수 사용 예시

```
// 단일값
출력(시그모이드(0.0))    // 0.5
출력(렐루(-3.0))         // 0.0
출력(쌍곡탄젠트(1.0))   // 0.7616...

// 배열 원소 일괄 적용 (원소별 변환)
배열 로짓 = [-1.0, 0.0, 1.0, 2.0]
출력(시그모이드(로짓))  // [0.269, 0.5, 0.731, 0.880]
출력(렐루(로짓))         // [0.0, 0.0, 1.0, 2.0]
출력(쌍곡탄젠트(로짓)) // [-0.762, 0.0, 0.762, 0.964]
```

```
// ① 평균제곱오차 — 회귀 모델 손실 계산
배열 예측 = [2.5, 0.0, 2.0, 8.0]
배열 실제  = [3.0, -0.5, 2.0, 7.0]
실수 손실 = 평균제곱오차(예측, 실제)
출력(손실)   // 0.1875

// ② 교차엔트로피 — 분류 모델 손실 (원-핫 레이블)
배열 정답분포 = [0.0, 1.0, 0.0]
배열 예측분포 = [0.1, 0.7, 0.2]
실수 손실2 = 교차엔트로피(정답분포, 예측분포)
출력(손실2)  // 0.3567...

// ③ 소프트맥스 — 신경망 출력층 (다중 분류)
배열 로짓 = [1.0, 2.0, 3.0]
배열 확률 = 소프트맥스(로짓)
출력(확률)   // [0.09, 0.245, 0.665] 합계=1.0

// ④ 위치인코딩 — Transformer PE 벡터 생성
배열 pe = 위치인코딩(0, 4)   // 위치 0, 차원 4
출력(pe)     // [sin(0), cos(0), sin(0/100), cos(0/100)]

// ⑤ 등비수열합 — 무한 등비급수 수렴값
실수 합 = 등비수열합(1.0, 0.5)   // 1/(1-0.5) = 2.0
출력(합)

// ⑥ 등차수열합 — 1+2+...+100
실수 합2 = 등차수열합(1.0, 1.0, 100)   // 5050.0
출력(합2)

// ⑦ 점화식값 — a₁=2, r=3 인 등비수열의 5번째 항
실수 항 = 점화식값(2.0, 3.0, 5)   // 2*3^4 = 162.0
출력(항)
```

### 배열 내장 속성

배열.길이    // 배열 원소 수
문자열.길이  // 문자열 길이

-----

## 17.5. 글자 함수 (v7.0.0)

-----

| 함수명      | 설명                                   |
|-------------|----------------------------------------|
| 자르기(글자, 시작, 끝) | 부분 문자열 추출 (Python의 str[start:end] 유사) |
| 분할(글자, 구분자) | 구분자로 문자열 분할 → 배열 반환 |
| 합치기(배열, 구분자) | 배열 원소를 구분자로 연결 → 문자열 |
| 포함(글자, 찾을글자) | 문자열 포함 여부 → 논리 (true/false) |
| 위치(글자, 찾을글자) | 찾을글자의 시작 위치 → 정수 (없으면 -1) |

### 사용 예시

```
// ① 자르기(문자열, 시작, 끝)
글자 인사 = "안녕하세요"
글자 부분 = 자르기(인사, 0, 2)    // "안녕"
글자 뒷부분 = 자르기(인사, 3, -1) // "세요"

// ② 분할(문자열, 구분자) → 배열
글자 데이터 = "홍길동,김철수,이영희"
배열 이름들 = 분할(데이터, ",")    // ["홍길동", "김철수", "이영희"]

// ③ 합치기(배열, 구분자) → 문자열
배열 과일 = ["사과", "바나나", "포도"]
글자 결과 = 합치기(과일, ", ")     // "사과, 바나나, 포도"

// ④ 포함(문자열, 찾을글자) → 논리
만약 포함("이메일@test.com", "@"):
    출력("유효한 이메일")

// ⑤ 위치(문자열, 찾을글자) → 정수
정수 위치값 = 위치("홍길동", "길")  // 1
만약 위치값 != -1:
    출력("찾음: 위치 " + 글자(위치값))
```

-----



-----

파일열기는 `파일열기(경로, 모드)` 형식으로 파일 핸들을 반환하며,
아래 함수들로 읽기/쓰기/관리를 수행합니다.

| 함수명                        | 설명                              |
|------------------------------|----------------------------------|
| `파일열기(경로, 모드)`          | 파일 열기 — 모드: "읽기"/"쓰기"/"추가" |
| `파일닫기(핸들)`               | 파일 닫기 (fclose)                 |
| `파일전체읽기(경로)`            | 열기+읽기+닫기 한 번에             |
| `파일전체쓰기(경로, 내용)`       | 열기+쓰기+닫기 한 번에             |
| `파일줄읽기(핸들)`             | 한 줄 읽기 (fgets)                 |
| `파일줄쓰기(핸들, 내용)`        | 한 줄 쓰기 + 개행 (fputs+\n)       |
| `파일읽기(핸들)`               | 전체 내용 읽기 (fread)             |
| `파일쓰기(핸들, 내용)`          | 내용 쓰기 (fputs)                  |
| `파일있음(경로)`               | 파일 존재 여부 (논리)              |
| `파일크기(경로)`               | 파일 크기 (정수, 바이트)           |
| `파일목록(경로)`               | 디렉토리 내 파일 목록 (배열)        |
| `파일이름(경로)`               | 파일 이름만 추출 (basename)        |
| `파일확장자(경로)`             | 확장자 추출                        |
| `폴더만들기(경로)`             | 디렉토리 생성 (mkdir)              |
| `파일지우기(경로)`             | 파일 삭제 (remove)                 |
| `파일복사(원본, 대상)`          | 파일 복사                          |
| `파일이동(원본, 대상)`          | 파일 이동/이름변경 (rename)        |

```
// 예시
글자 내용 = 파일전체읽기("데이터.txt")
파일전체쓰기("결과.txt", 내용)

만약 파일있음("설정.json"):
    정수 크기 = 파일크기("설정.json")
    출력("파일 크기: " + 글자(크기))

배열 목록 = 파일목록("./데이터/")
각각 파일 안에 목록:
    출력(파일이름(파일) + " (" + 파일확장자(파일) + ")")
```

-----

## 19. 계약 시스템 (v5.0.0 — Design by Contract)

-----

실제 법률 체계와 동일한 5계층 구조로 런타임 계약 검증을 수행합니다.
우선순위: **헌법 → 법률 → 규정 → 법령 → 법위반** 순 평가.
상위 계층에서 중단 제재 발생 시 하위 계층은 평가하지 않습니다.

```
헌법    ← 모든 파일 전역 (인라인)
법률    ← 현재 파일 전체 (인라인)
규정    ← 특정 객체 전체 메서드 (블록)
법령    ← 특정 함수 사전조건 (블록)
법위반  ← 특정 함수 사후조건 (블록)
```

### 제재 종류

| 키워드 | 설명                              |
|-------|----------------------------------|
| `경고` | 경고 메시지 출력 후 계속 실행      |
| `보고` | 로그 기록 후 계속 실행            |
| `중단` | 오류 발생 후 실행 중단            |
| `회귀` | 복원지점으로 상태 복원            |
| `대체` | 대체값/함수로 반환값 교체          |

### 헌법 — 전역 최상위 계약 (인라인)

```
헌법 [조건], [제재]
```

```
헌법 입력 != 없음, 중단
헌법 반환값 != 없음, 경고
```

### 법률 — 현재 파일 전체 계약 (인라인)

```
법률 [조건], [제재]
```

```
법률 메모리 < 1024, 보고
```

### 규정 — 특정 객체 전체 메서드 계약 (블록)

```
규정 [객체명]:
    조항 [조건]
    제재 [제재종류]
규정끝
```

```
규정 계좌:
    조항 잔액 >= 0
    제재 중단
규정끝
```

### 법령 — 특정 함수 사전조건 (블록)

```
법령 [함수명]:
    조항 [조건]
    제재 [제재종류]
법령끝
```

```
법령 인출:
    조항 금액 > 0
    조항 금액 <= 잔액
    제재 중단
법령끝
```

### 법위반 — 특정 함수 사후조건 (블록)

```
법위반 [함수명]:
    조항 [조건]
    제재 [제재종류]
법위반끝
```

```
법위반 인출:
    조항 잔액 >= 0
    제재 회귀 인출전상태
법위반끝
```

### 복원지점 선언

```
복원지점 [이름]
```

```
복원지점 인출전상태
정수 이전잔액 = 잔액
인출(50000)
```

-----

## 20. 인터럽트 시스템 (v6.0.0)

-----

3종의 인터럽트 시스템을 지원합니다.

### A. OS 시그널 (신호)

```
// 신호 핸들러 등록
신호받기 [신호이름]:
    [핸들러 블록]
신호받기끝

// 신호 제어
신호무시 [신호이름]       // SIG_IGN
신호기본 [신호이름]       // SIG_DFL
신호보내기 [PID] [신호이름]  // kill(pid, sig)
```

**지원 신호 이름:**

| 키워드     | 신호         | 설명              |
|-----------|-------------|------------------|
| `중단신호` | SIGINT      | Ctrl+C           |
| `종료신호` | SIGTERM     | 정상 종료 요청    |
| `강제종료` | SIGKILL     | 강제 종료        |
| `자식신호` | SIGCHLD     | 자식 프로세스 종료|
| `사용자신호1` | SIGUSR1   | 사용자 정의 1    |
| `사용자신호2` | SIGUSR2   | 사용자 정의 2    |
| `연결신호` | SIGPIPE     | 파이프 끊김      |
| `경보신호` | SIGALRM     | 알람 타이머      |
| `중지신호` | SIGSTOP     | 프로세스 중지    |
| `재개신호` | SIGCONT     | 프로세스 재개    |

```
// 예시
신호받기 중단신호:
    출력("Ctrl+C 감지 — 정리 중...")
    행사중단
신호받기끝

신호무시 연결신호
```

### B. 하드웨어 간섭 (ISR)

```
// ISR 핸들러 등록
간섭 [벡터이름]:
    [ISR 블록]
간섭끝

// 인터럽트 잠금/해제
간섭잠금    // cli() / noInterrupts()
간섭허용    // sei() / interrupts()
```

**지원 벡터 이름:**

| 키워드      | AVR 벡터           |
|------------|-------------------|
| `시간0넘침` | TIMER0_OVF_vect  |
| `시간1넘침` | TIMER1_OVF_vect  |
| `외부0상승` | INT0_vect (상승) |
| `외부0하강` | INT0_vect (하강) |
| `직렬수신`  | USART_RX_vect    |

```
// 예시
간섭 시간0넘침:
    카운터 = 카운터 + 1
간섭끝

간섭잠금
    공유데이터 = 새값
간섭허용
```

### C. 행사 (이벤트 루프)

```
// 이벤트 핸들러 등록
행사등록 [이벤트이름] 처리[(매개변수...)]:
    [핸들러 블록]
행사등록끝

// 이벤트 루프 제어
행사시작        // 이벤트 루프 진입 (blocking)
행사중단        // 이벤트 루프 종료
행사발생 [이름] // 이벤트 수동 발생
행사해제 [이름] // 핸들러 제거
```

```
// 예시
행사등록 클릭 처리(정수 x, 정수 y):
    출력("클릭: " + 글자(x) + "," + 글자(y))
행사등록끝

행사등록 종료 처리():
    행사중단
행사등록끝

행사시작   // 루프 진입 — 이벤트가 올 때까지 대기
```

-----

## 21. 가속기 블록 (GPU / NPU / CPU) — v8.2.0

-----

`가속기` 키워드로 GPU·NPU·CPU 하드웨어 가속 연산 블록을 정의합니다.  
내장 연산(행렬곱·행렬합·합성곱·활성화·전치)은 CUDA C로 자동 변환되어  
`nvcc` 컴파일 → 실행 → 결과 수집 파이프라인으로 처리됩니다.

-----

### 21.1 기본 문법

```
가속기 [종류]:
    내장연산(인수, ...) => 결과변수
    ...일반 Kcode 코드...
가속기끝
```

| 항목 | 설명 |
|------|------|
| `종류` | `GPU` / `NPU` / `CPU` — 생략 시 GPU→NPU→CPU 자동 선택 |
| `내장연산(...)` | 가속기 전용 내장 함수 (5종, 아래 표 참고) |
| `=> 결과변수` | 연산 결과를 저장할 변수 (선택) |
| `가속기끝` | 블록 종료 키워드 |

-----

### 21.2 종류(타입) 지정

```
가속기 GPU:          // CUDA C → nvcc 컴파일 실행
    행렬곱(A, B) => 결과
가속기끝

가속기 NPU:          // ONNX Runtime 위임 (onnxruntime 설치 필요)
    합성곱(이미지, 커널) => 출력
가속기끝

가속기 CPU:          // OpenMP 병렬 코드 생성 (gcc -fopenmp)
    행렬합(A, B) => 결과
가속기끝

가속기:              // 종류 생략 → GPU 우선, 실패 시 CPU 폴백
    행렬곱(A, B) => 결과
가속기끝
```

| Kcode 키워드 | 백엔드 | 필요 도구 |
|-------------|--------|----------|
| `GPU` | nvcc (CUDA C 자동 생성) | NVIDIA CUDA Toolkit |
| `NPU` | ONNX Runtime C API | onnxruntime |
| `CPU` | OpenMP 병렬 (`#pragma omp parallel`) | gcc -fopenmp |
| (생략) | GPU→NPU→CPU 순 자동 폴백 | — |

-----

### 21.3 내장 연산 함수 5종

| 함수명 | 설명 | CUDA 커널 |
|--------|------|-----------|
| `행렬곱(A, B) => 결과` | 행렬 곱셈 (GEMM) | `kc_kernel_matmul` |
| `행렬합(A, B) => 결과` | 원소별 덧셈 | `kc_kernel_matadd` |
| `합성곱(이미지, 커널) => 출력` | 2D 합성곱 | `kc_kernel_conv2d` |
| `활성화(A, "relu") => 결과` | 활성화 함수 (relu/sigmoid/tanh) | `kc_kernel_activate` |
| `전치(A) => 결과` | 행렬 전치 | `kc_kernel_transpose` |

> **활성화 함수 모드**  
> `"relu"` → ReLU (mode=0) / `"sigmoid"` → 시그모이드 (mode=1) / `"tanh"` → 쌍곡탄젠트 (mode=2)  
> 환경변수 `KCODE_MODE`로 전달됩니다.

-----

### 21.4 변수 전달 방식

가속기 내장 연산의 인수(배열/행렬)는 환경변수 CSV 직렬화로 전달됩니다.

```
// HOST측 자동 처리 (C/LLVM 백엔드 모두 동일)
setenv("KCODE_A", "1.0,2.0,3.0,...")   // 배열 CSV
setenv("KCODE_N",    "1024")            // 원소 수
setenv("KCODE_ROWS", "32")             // 행 수 (행렬 연산 시)
setenv("KCODE_COLS", "32")             // 열 수 (행렬 연산 시)
setenv("KCODE_MODE", "0")              // 활성화 모드 (활성화 연산 시)
```

결과는 GPU 바이너리 stdout의 CSV를 역직렬화하여 반환 변수에 저장합니다.

-----

### 21.5 폴백 체인

```
GPU 시도:
  nvcc 없음 또는 컴파일 실패
    ↓
  CPU 폴백 (OpenMP)
    → 경고 출력: "[가속기] nvcc 없음 — CPU 폴백으로 전환"
    → #pragma omp parallel 병렬 실행
```

-----

### 21.6 생성되는 CUDA C 구조 예시

```cuda
/* Kcode 자동 생성 CUDA C — 가속기 블록 */
#include <cuda_runtime.h>

__global__ void kc_kernel_matmul(
    double *r, const double *a, const double *b,
    long long rows, long long cols) {
    long long row = blockIdx.y * blockDim.y + threadIdx.y;
    long long col = blockIdx.x * blockDim.x + threadIdx.x;
    if (row < rows && col < cols) {
        double s = 0.0;
        for (long long k = 0; k < cols; k++)
            s += a[row*cols+k] * b[k*cols+col];
        r[row*cols+col] = s;
    }
}

int main(void) {
    long long N    = atoll(getenv("KCODE_N")    ?: "1");
    long long ROWS = atoll(getenv("KCODE_ROWS") ?: "1");
    long long COLS = atoll(getenv("KCODE_COLS") ?: "1");

    // 입력 배열 환경변수 역직렬화
    double *h_A = malloc(N * sizeof(double));
    double *h_B = malloc(N * sizeof(double));
    double *h_결과 = malloc(N * sizeof(double));
    kc_csv_parse(getenv("KCODE_A"), h_A, N);
    kc_csv_parse(getenv("KCODE_B"), h_B, N);

    // CUDA 메모리 할당 + 커널 실행
    double *d_a, *d_b, *d_r;
    cudaMalloc(&d_a, N*sizeof(double));
    cudaMalloc(&d_b, N*sizeof(double));
    cudaMalloc(&d_r, N*sizeof(double));
    cudaMemcpy(d_a, h_A, N*sizeof(double), cudaMemcpyHostToDevice);
    cudaMemcpy(d_b, h_B, N*sizeof(double), cudaMemcpyHostToDevice);
    dim3 thr(16,16), blk((COLS+15)/16, (ROWS+15)/16);
    kc_kernel_matmul<<<blk,thr>>>(d_r, d_a, d_b, ROWS, COLS);
    cudaDeviceSynchronize();
    cudaMemcpy(h_결과, d_r, N*sizeof(double), cudaMemcpyDeviceToHost);

    // 결과 CSV 출력 → Kcode가 수집
    for (long long i = 0; i < N; i++)
        printf("%s%.17g", i?",":"", h_결과[i]);
    printf("\n");
    return 0;
}
```

파일 경로: `/tmp/_kcode_gpu_<PID>.cu` (실행 후 자동 삭제)

-----

### 21.7 실행 흐름 (인터프리터 / C코드생성 / LLVM IR 공통)

```
1. 입력 배열 변수 → setenv("KCODE_변수명", CSV문자열) 직렬화
2. CUDA C 코드 자동 생성 → /tmp/_kcode_gpu_<PID>.cu 저장
3. nvcc /tmp/_kcode_gpu_<PID>.cu -o /tmp/_kcode_gpu_<PID>.out -O2 -lm
4. /tmp/_kcode_gpu_<PID>.out > /tmp/_kcode_gpu_<PID>.out.res
5. stdout CSV → 결과 변수에 역직렬화 후 저장
6. 임시 파일 (.cu / .log / .out / .res) 삭제
```

-----

### 21.8 사용 예제

```
// 기본 행렬 덧셈 (GPU)
배열 A = [1.0, 2.0, 3.0, 4.0]
배열 B = [5.0, 6.0, 7.0, 8.0]
배열 C = []

가속기 GPU:
    행렬합(A, B) => C
가속기끝

출력(C)  // [6.0, 8.0, 10.0, 12.0]
```

```
// 행렬 곱셈 (자동 선택 — GPU 우선)
배열 W = [...]
배열 X = [...]
배열 출력값 = []

가속기:
    행렬곱(W, X) => 출력값
    활성화(출력값, "relu") => 출력값
가속기끝
```

```
// CPU 전용 — OpenMP 병렬
가속기 CPU:
    행렬합(A, B) => 결과
가속기끝
```

-----

## 22. 스크립트 블록

-----

외부 언어 코드를 Kcode 내부에 직접 삽입하여 실행합니다.

### 파이썬 블록

```
파이썬:
    print("파이썬 코드")
파이썬끝
```

### 변수 전달 및 반환

```
파이썬(변수1, 변수2) => 반환변수:
    # 전달받은 변수 사용 가능
    result = 변수1 + 변수2
    print(result)
파이썬끝
```

### 자바 블록

```
자바:
    public class Main {
        public static void main(String[] args) {
            System.out.println("자바 실행!");
        }
    }
자바끝
```

### 자바스크립트 블록

```
자바스크립트 => 결과:
    const arr = [1,2,3];
    console.log(arr.reduce((a,b)=>a+b,0));
자바스크립트끝
```

### 스크립트 블록 공통 문법

```
[언어키워드][(전달변수, ...)] [=> 반환변수]:
    [외부 언어 코드 원문]
끝[언어키워드]
```

| 언어 | 시작 | 종료 | 실행 방법 |
|------|------|------|----------|
| Python | 파이썬 | 파이썬끝 | python3 실행 → stdout |
| Java | 자바 | 자바끝 | javac+java 실행 → stdout |
| JavaScript | 자바스크립트 | 자바스크립트끝 | node 실행 → stdout |

-----

## 23. 전처리기 디렉티브

-----

전처리기 구문은 `#` 뒤에 한글 키워드를 붙여 사용합니다.

```
#정의 [이름] [값]           // 상수 또는 매크로 정의
#포함 [파일명]              // 외부 파일 포함 (v6.1.0 — 8종 확장자)
#만약 [조건]                // 조건부 컴파일 시작
#아니면                     // 조건부 컴파일 분기
#끝                         // 조건부 컴파일 종료
#만약있으면 [이름]          // 이름이 정의된 경우
#만약없으면 [이름]          // 이름이 정의되지 않은 경우
#GPU사용                    // GPU 가속 활성화
```

예)
```
#정의 최대크기 100
#포함 "수학라이브러리.hg"

#만약있으면 디버그
    출력("디버그 모드")
#끝
```

-----

## 24. 화면/렌더링 키워드

-----

화면      - 2D 윈도우 생성
화면3D    - 3D 윈도우 생성
사진열기  - 이미지 파일 열기
그림만들기 - 캔버스 생성

-----

## 25. AI 연결

-----

AI연결    - 외부 LLM 모델 연결

-----

## 26. 들여쓰기 규칙

-----

Python과 동일하게 들여쓰기 기반으로 블록을 구분합니다.
스페이스 또는 탭 일관되게 사용 (혼용 금지).
블록 시작은 `:` (콜론)으로 표시합니다.

예)
만약 조건:
    // 들여쓰기된 블록
    출력("블록 내부")
// 들여쓰기 종료 = 블록 종료

-----

## 27. 통합 예제 (v8.2.0)

-----

```
// 모듈 가져오기
가짐 수학
#포함 "공통유틸.han"

// 상수 선언
고정 정수 최대 = 100

// 배열 및 사전
배열 점수 = [85, 92, 78, 95, 88]
사전 학생정보 = {"이름": "홍길동", "학년": 3}

// 람다
함수형 두배 = (정수 x) => x * 2

// 계약 시스템 — 사전/사후조건
법령 평균계산:
    조항 길이(값들) > 0
    제재 중단
법령끝

함수 평균계산(배열 값들):
    정수 합 = 0
    각각 v 안에 값들:
        합 += v
    반환 합 / 길이(값들)

// 클래스 (vtable LLVM IR 지원 v6.2.0)
객체 학생:
    글자 이름
    정수 점수

    함수 생성(자신, 글자 이름, 정수 점수):
        자신.이름 = 이름
        자신.점수 = 점수

    함수 등급(자신):
        선택 자신.점수 / 10
            경우 10:
            경우 9:
                반환 "A"
            경우 8:
                반환 "B"
            그외:
                반환 "C 이하"

// 인터럽트 — OS 시그널
신호받기 중단신호:
    출력("종료 중...")
    행사중단
신호받기끝

// 예외 처리
시도:
    정수 결과 = 10 / 0
실패시:
    출력("오류: " + 오류)

// 파이썬 연동
정수 평균값 = 0
파이썬(점수) => 평균값:
    print(int(sum(점수) / len(점수)))
파이썬끝

출력("평균: " + 글자(평균값))

// ── 가속기 블록 (v8.2.0) ──────────────────────────────
// GPU 행렬 연산 파이프라인
배열 가중치 = [0.1, 0.2, 0.3, 0.4,
               0.5, 0.6, 0.7, 0.8,
               0.9, 1.0, 1.1, 1.2,
               1.3, 1.4, 1.5, 1.6]
배열 입력값  = [1.0, 2.0, 3.0, 4.0,
               5.0, 6.0, 7.0, 8.0,
               9.0, 10.0, 11.0, 12.0,
               13.0, 14.0, 15.0, 16.0]
배열 출력값  = []
배열 활성값  = []

가속기 GPU:
    행렬곱(가중치, 입력값) => 출력값
    활성화(출력값, "relu") => 활성값
가속기끝

출력("GPU 연산 결과: " + 글자(활성값))

// CPU 폴백 예제 — nvcc 없는 환경에서 사용
배열 X = [1.0, 2.0, 3.0]
배열 Y = [4.0, 5.0, 6.0]
배열 Z = []

가속기 CPU:
    행렬합(X, Y) => Z
가속기끝

출력("CPU 결과: " + 글자(Z))
```

-----

## 28. 텐서(Tensor) 자료형 — v12.0.0

> N차원 밀집(dense) 텐서. double 정밀도, 행 우선(row-major) 저장.
> GC 관리 대상. 자동미분 연동 필드(requires_grad, grad, grad_fn) 포함.

-----

### 28-1. 텐서 생성

```han
// 데이터 + 형태로 생성
텐서 A = 텐서생성([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [2, 3])  // 2×3

// 영텐서 / 일텐서 / 무작위텐서
텐서 B = 텐서생성([0.0, 0.0, 0.0, 0.0], [2, 2])   // 영텐서 직접 지정
```

### 28-2. 정보 조회

```han
텐서형태(A)   // "[2, 3]"  (문자열 반환)
텐서크기(A)   // 6         (정수 — 전체 원소 수)
텐서차원(A)   // 2         (정수 — 차원 수)
```

### 28-3. 집계 연산

```han
텐서합(A)     // 전체 원소 합 (실수)
텐서평균(A)   // 전체 평균  (실수)
텐서최대(A)   // 최댓값    (실수)
텐서최소(A)   // 최솟값    (실수)
```

### 28-4. 변형 연산

```han
텐서 B = 텐서변형(A, [6])      // reshape — numel 동일해야 함
텐서 C = 텐서평탄화(A)          // flatten → 1차원
텐서 D = 텐서전치(A)            // 2D 전치
텐서 E = 텐서복사(A)            // 깊은 복사
```

### 28-5. 행렬 연산

```han
텐서 X = 텐서생성([1.0,2.0,3.0,4.0], [2,2])
텐서 Y = 텐서생성([5.0,6.0,7.0,8.0], [2,2])

텐서 Z = 텐서행렬곱(X, Y)      // 행렬곱 [m,k] @ [k,n] → [m,n]
```

### 28-6. 내장 함수 12종 요약

| 함수 | 설명 | 반환 |
|------|------|------|
| 텐서생성(데이터, 형태) | 데이터 배열 + 형태 배열로 텐서 생성 | 텐서 |
| 텐서형태(t) | 형태 문자열 "[d0, d1, ...]" | 문자 |
| 텐서크기(t) | 전체 원소 수 | 정수 |
| 텐서차원(t) | 차원 수 | 정수 |
| 텐서합(t) | 전체 원소 합 | 실수 |
| 텐서평균(t) | 전체 평균 | 실수 |
| 텐서최대(t) | 최댓값 | 실수 |
| 텐서최소(t) | 최솟값 | 실수 |
| 텐서행렬곱(a, b) | 2D 행렬곱 | 텐서 |
| 텐서전치(t) | 2D 전치 | 텐서 |
| 텐서변형(t, 형태) | reshape | 텐서 |
| 텐서평탄화(t) | flatten → 1D | 텐서 |
| 텐서복사(t) | 깊은 복사 | 텐서 |

-----

## 29. 자동미분(Autograd) — v13.0.0

> 테이프 방식(PyTorch 스타일) 동적 연산 그래프 + 역전파 엔진.
> requires_grad=참 으로 선언된 텐서의 연산을 자동으로 추적한다.
> v12.0.0 텐서 자료형이 선행되어야 한다.

-----

### 29-1. 미분추적 텐서 선언

```han
// 미분추적 활성화: 텐서생성 후 requires_grad 필드를 참으로 설정
텐서 x = 텐서생성([2.0], [1])
텐서 w = 텐서생성([3.0], [1])
// 인터프리터에서 requires_grad 활성화는 kc_ag_* 래퍼 함수로 자동 처리
```

### 29-2. 역전파 실행

```han
// y = x² + w * 2.0 계산 (계산 그래프 자동 기록)
텐서 x2 = 텐서행렬곱(x, x)
텐서 w2 = 텐서행렬곱(w, 텐서생성([2.0], [1]))
텐서 y  = x2 + w2          // 원소별 덧셈

역전파(y)                   // 연쇄법칙 역전파 실행 — y는 스칼라(numel=1)이어야 함

출력(텐서합(x.기울기))      // dy/dx = 2x = 4.0
출력(텐서합(w.기울기))      // dy/dw = 2.0
```

### 29-3. 기울기 초기화

```han
기울기초기화(x)   // x.grad 버퍼를 0으로 초기화
기울기초기화(w)   // 다음 역전파 전 항상 초기화 필요
```

### 29-4. 지원 역전파 연산 10종

| 연산 | 순전파 | 역전파 |
|------|--------|--------|
| 덧셈 | z = a + b | da = 1, db = 1 |
| 뺄셈 | z = a - b | da = 1, db = -1 |
| 곱셈 | z = a * b | da = b, db = a |
| 나눗셈 | z = a / b | da = 1/b, db = -a/b² |
| 행렬곱 | Z = A @ B | dA = G@Bᵀ, dB = Aᵀ@G |
| 렐루 | z = relu(a) | da = (a > 0) ? 1 : 0 |
| 시그모이드 | z = σ(a) | da = z*(1-z) |
| 쌍곡탄젠트 | z = tanh(a) | da = 1 - z² |
| 제곱 | z = a² | da = 2*a |
| 합산 | z = sum(a) | da = broadcast(1) |

### 29-5. 내장 함수 2종

| 함수 | 설명 |
|------|------|
| 역전파(텐서) | 스칼라 텐서에서 역전파 시작 (numel=1 필수) |
| 기울기초기화(텐서) | 텐서의 grad 버퍼를 0으로 초기화 |

### 29-6. 내부 구조체 (GradFn)

```c
typedef struct GradFn {
    void (*backward)(struct GradFn*, const double *grad_out, int64_t numel);
    KcTensor *saved[4];       /* 역전파에 필요한 저장 텐서 */
    int       n_saved;
    struct GradFn *next_fns[4]; /* 이전 노드 연결 (계산 그래프) */
    int       n_next;
    KcTensor *inputs[4];      /* 기울기 누적 대상 입력 텐서 */
    int       n_inputs;
    const char *op_name;      /* 디버그용 연산 이름 */
} GradFn;
```

### 29-7. 종합 예제 — MSE 손실 역전파

```han
// 예측값과 정답으로 MSE 손실 계산 후 역전파
텐서 예측 = 텐서생성([2.0, 3.0, 4.0], [3])
텐서 정답 = 텐서생성([1.0, 2.0, 3.0], [3])

// 오차 = 예측 - 정답
텐서 오차 = 예측 - 정답           // [1.0, 1.0, 1.0]

// MSE = sum(오차²) / n
텐서 오차제곱 = 오차 * 오차       // [1.0, 1.0, 1.0]
텐서 손실    = 텐서생성([텐서합(오차제곱) / 3.0], [1])

역전파(손실)

출력("예측 기울기: " + 텐서형태(예측))
기울기초기화(예측)
```

-----

-----

## 28. 텐서(Tensor) 자료형 — v12.0.0

> N차원 밀집(dense) 텐서. double 정밀도. 행 우선(row-major) 저장.
> GC 관리 대상. v13.0.0 자동미분과 연동.

-----

### 28.1 텐서 생성

```han
// 데이터 배열 + 형태 배열로 생성
텐서 A = 텐서생성([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [2, 3])  // 2×3

// 특수 생성
텐서 B = 영텐서([3, 4])     // 0으로 초기화된 3×4
텐서 C = 일텐서([2, 2])     // 1로 초기화된 2×2
텐서 D = 무작위텐서([128, 256])  // 랜덤 128×256

// 미분 추적 활성화 (v13.0.0 자동미분 연동)
텐서 x = 텐서생성([2.0], [1])
x.미분추적 = 참
```

-----

### 28.2 텐서 속성

```han
A.형태    // → "[2, 3]" (글자)
A.차원    // → 2 (정수)
A.원소수  // → 6 (정수)
A.기울기  // → 기울기 버퍼 (역전파 후 채워짐, v13.0.0)
A.미분추적 // → 참/거짓
```

-----

### 28.3 텐서 내장 함수 12종

| 분류 | 함수 | 설명 |
|------|------|------|
| 정보 | 텐서형태(t) | 형태 문자열 반환 "[d0, d1, ...]" |
| 정보 | 텐서크기(t) | 전체 원소 수 (정수) |
| 정보 | 텐서차원(t) | 차원 수 (정수) |
| 집계 | 텐서합(t) | 전체 합 (실수) |
| 집계 | 텐서평균(t) | 전체 평균 (실수) |
| 집계 | 텐서최대(t) | 최댓값 (실수) |
| 집계 | 텐서최소(t) | 최솟값 (실수) |
| 행렬 | 텐서행렬곱(a, b) | 행렬곱 [m,k]×[k,n]→[m,n] |
| 행렬 | 텐서전치(t) | 2D 전치 |
| 변형 | 텐서변형(t, 형태) | reshape (numel 동일해야 함) |
| 변형 | 텐서평탄화(t) | 1차원으로 평탄화 |
| 복사 | 텐서복사(t) | 깊은 복사 |

```han
텐서 A = 텐서생성([1.0, 2.0, 3.0, 4.0], [2, 2])
텐서 B = 텐서전치(A)           // [[1,3],[2,4]]
텐서 C = 텐서행렬곱(A, B)      // 2×2 행렬곱
텐서 D = 텐서변형(A, [4])      // 1×4로 reshape
실수 합 = 텐서합(A)            // 10.0
출력(텐서형태(A))              // "[2, 2]"
```

-----

### 28.4 텐서 연산자

```han
텐서 A = 텐서생성([1.0, 2.0], [2])
텐서 B = 텐서생성([3.0, 4.0], [2])

텐서 C = A + B   // 원소별 덧셈 → [4.0, 6.0]
텐서 D = A * B   // 원소별 곱셈 → [3.0, 8.0]
텐서 E = A @ B   // 행렬곱 (2D 전용)
```

-----

## 29. 자동미분(Autograd) 엔진 — v13.0.0

> 테이프 방식(PyTorch 스타일) 동적 연산 그래프 + 역전파 엔진.
> 텐서에 `미분추적=참` 설정 시 연산 그래프가 자동 기록된다.
> `역전파()` 호출 시 연쇄법칙으로 기울기 자동 계산.

-----

### 29.1 기본 문법

```han
// 미분 추적 텐서 생성
텐서 x = 텐서생성([2.0], [1])
x.미분추적 = 참

텐서 w = 텐서생성([3.0], [1])
w.미분추적 = 참

// 연산 (계산 그래프 자동 기록)
텐서 y = x * x + w * 텐서생성([2.0], [1])

// 역전파 (연쇄법칙 자동 계산)
역전파(y)

출력(x.기울기)   // dy/dx = 2x = 4.0
출력(w.기울기)   // dy/dw = 2.0

// 다음 역전파 전 기울기 초기화
기울기초기화(x)
기울기초기화(w)
```

-----

### 29.2 역전파 내장 함수

| 함수 | 설명 |
|------|------|
| 역전파(텐서) | 스칼라 텐서에서 역전파 시작 (numel==1 필수) |
| 기울기초기화(텐서) | grad 버퍼를 0으로 초기화 |

-----

### 29.3 지원 역전파 연산 10종

| 연산 | 순전파 | 역전파 |
|------|--------|--------|
| 덧셈 | z = a + b | da=1, db=1 |
| 뺄셈 | z = a - b | da=1, db=-1 |
| 곱셈 | z = a * b | da=b, db=a |
| 나눗셈 | z = a / b | da=1/b, db=-a/b² |
| 행렬곱 | Z = A @ B | dA=G@Bᵀ, dB=Aᵀ@G |
| 렐루 | z = relu(a) | da = (a>0) ? 1 : 0 |
| 시그모이드 | z = σ(a) | da = z*(1-z) |
| 쌍곡탄젠트 | z = tanh(a) | da = 1-z² |
| 제곱 | z = a² | da = 2a |
| 합산 | z = sum(a) | da = 1 (브로드캐스트) |

-----

### 29.4 MSE 손실 역전파 예제

```han
// 단순 선형 회귀 1스텝
텐서 x = 텐서생성([1.0, 2.0, 3.0], [3])
x.미분추적 = 참

텐서 w = 텐서생성([0.5], [1])
w.미분추적 = 참

텐서 y_pred = x * w                         // 예측값
텐서 y_true = 텐서생성([1.0, 2.0, 3.0], [3])
텐서 diff   = y_pred - y_true               // 오차
텐서 loss   = 텐서합(diff * diff)           // MSE (스칼라)

역전파(loss)                                 // 역전파

출력("w 기울기: " + 글자(w.기울기))         // dL/dw
기울기초기화(w)
```

-----

### 29.5 GradFn 내부 구조 (참고)

```c
typedef struct GradFn {
    void (*backward)(struct GradFn*, const double *grad_out, int64_t numel);
    KcTensor *saved[4];       /* 순전파 시 저장된 텐서 */
    int       n_saved;
    struct GradFn *next_fns[4]; /* 이전 노드 (계산 그래프) */
    int       n_next;
    KcTensor *inputs[4];      /* grad 누적 대상 텐서 */
    int       n_inputs;
    const char *op_name;      /* 연산 이름 (디버그) */
} GradFn;
```

-----

-----

## 30. 산업/임베디드 확장 — v17.0.0

-----

### 30.1 타이머 블록

실시간 주기 제어 루프. 지정한 주기(ms 단위)마다 블록 내부를 실행한다.

```han
타이머 100ms:
    정수 온도 = I2C읽기(0x48)
    만약 온도 > 80:
        GPIO쓰기(13, 0)
타이머끝
```

### 30.2 ROS2 노드 블록

```han
ROS2노드 "센서처리":
    정수 값 = I2C읽기(0x48)
    ROS2발행("센서/온도", 글자(값))
ROS2끝
```

### 30.3 산업/임베디드 내장함수 22종

| 분류 | 함수 | 설명 |
|------|------|------|
| GPIO | `GPIO쓰기(핀, 값)` | 디지털 핀 출력 |
| GPIO | `GPIO읽기(핀)` | 디지털 핀 입력 |
| I2C | `I2C연결(주소)` | I2C 버스 초기화 |
| I2C | `I2C읽기(주소)` | I2C 레지스터 읽기 |
| I2C | `I2C쓰기(주소, 데이터)` | I2C 레지스터 쓰기 |
| SPI | `SPI전송(데이터)` | SPI 데이터 전송 |
| SPI | `SPI읽기()` | SPI 데이터 수신 |
| UART | `UART설정(보드레이트)` | 시리얼 초기화 |
| UART | `UART전송(데이터)` | 시리얼 전송 |
| UART | `UART읽기()` | 시리얼 수신 |
| Modbus | `Modbus연결(호스트, 포트)` | PLC 연결 |
| Modbus | `Modbus읽기(레지스터)` | 레지스터 읽기 |
| Modbus | `Modbus쓰기(레지스터, 값)` | 레지스터 쓰기 |
| CAN | `CAN필터(ID, 마스크)` | 메시지 필터 설정 |
| CAN | `CAN전송(ID, 데이터)` | CAN 프레임 전송 |
| CAN | `CAN읽기()` | CAN 프레임 수신 |
| MQTT | `MQTT연결(브로커, 포트)` | 브로커 연결 |
| MQTT | `MQTT발행(토픽, 메시지)` | 토픽 발행 |
| MQTT | `MQTT구독(토픽)` | 토픽 구독 |
| MQTT | `MQTT연결끊기()` | 연결 해제 |
| ROS2 | `ROS2발행(토픽, 메시지)` | ROS2 토픽 발행 |
| ROS2 | `ROS2구독(토픽)` | ROS2 토픽 구독 |

-----

## 31. 안전 규격 (IEC 61508 / ISO 26262) — v18.0.0

-----

### 31.1 SIL 선언

계약 시스템에 안전 등급을 선언한다.

```han
헌법 기계안전 SIL=2:
    법률 압력제어:
        법령:
            압력 < 최대압력
        법위반:
            긴급정지()
            페일세이프()
    법률끝
헌법끝
```

### 31.2 워치독 블록

지정 시간 내에 블록이 완료되지 않으면 워치독이 발동한다.

```han
워치독 500ms:
    정수 온도 = I2C읽기(0x48)
    GPIO쓰기(13, 온도 > 80 ? 0 : 1)
워치독끝
```

### 31.3 결함허용 블록

N중 복제 실행으로 단일 경로 고장 시에도 동작을 보장한다.

```han
결함허용 3중:
    정수 값1 = 센서읽기(0)
    정수 값2 = 센서읽기(1)
    정수 값3 = 센서읽기(2)
결함허용끝
```

### 31.4 안전 내장함수 3종

| 함수 | 설명 |
|------|------|
| `페일세이프()` | 모든 출력을 안전 상태로 전환 |
| `긴급정지()` | 시스템 즉시 정지 |
| `경보발령(메시지)` | 안전 경보 발령 및 로그 기록 |

-----

## 32. 온디바이스 AI (ONNX / TinyML / 연합학습) — v19.0.0

-----

### 32.1 AI모델 블록

```han
AI모델 "불량감지":
    정수 모델 = AI불러오기("detect.onnx")
    실행:
        정수 결과 = AI추론(모델)
        만약 결과 == 1:
            경보발령("불량품 감지")
AI모델끝
```

### 32.2 TinyML 블록 (MCU 경량 모델)

```han
TinyML "온도예측":
    정수 모델 = AI불러오기("temp.tflite")
    실행:
        정수 예측 = AI추론(모델)
        AI학습단계(모델)
        AI저장(모델, "temp_updated.tflite")
TinyML끝
```

### 32.3 연합학습 블록

```han
연합학습:
    정수 로컬모델 = AI불러오기("local.bin")
    AI학습단계(로컬모델)
    AI저장(로컬모델, "local_v2.bin")
연합학습끝
```

### 32.4 AI 내장함수 4종

| 함수 | 설명 |
|------|------|
| `AI불러오기(경로)` | ONNX / TFLite 모델 로드 → 핸들 반환 |
| `AI추론(핸들)` | 모델 추론 실행 → 결과 반환 |
| `AI학습단계(핸들)` | 온디바이스 1스텝 학습 |
| `AI저장(핸들, 경로)` | 모델 가중치 저장 |

-----

## 33. 온톨로지 블록 — v20.0.0

-----

### 33.1 모드 구분

| 모드 | 키워드 | 설명 |
|------|--------|------|
| 모드 1 | `온톨로지 "내장"` | K엔진 + K서버 직접 운영 |
| 모드 2 | `온톨로지 "대여"` | libkc_ontology.so SDK 사용 |
| 모드 3 | `온톨로지 "접속" "URL"` | 외부 서버(Jena/GraphDB 등) 연결 |

### 33.2 온톨로지 블록 구문

```han
온톨로지 "내장":
    // 개념(클래스) 정의
    개념 "제품":
        속성 "이름" 글자
        속성 "가격" 실수
        속성 "고객번호" 정수 민감     // 민감정보 — 학습 차단
        속성 "계좌" 글자 익명화       // 저장 시 자동 익명화
    개념끝

    // 상속
    개념 "전자제품" 이어받기 "제품":
        속성 "전압" 실수
    개념끝

    // 관계 정의
    관계 "구매함" 사람 제품
    관계 "포함함" 제품 제품

    // 추론 블록
    추론:
        출력("추론 실행 완료")
    추론끝
온톨로지끝
```

### 33.3 모드 3 — 외부 서버 접속

```han
온톨로지 "접속" "http://192.168.1.10:8765":
    질의 "전자제품 찾기" => 결과
    출력(결과)
온톨로지끝
```

### 33.4 온톨로지 키워드 목록

| 키워드 | 설명 |
|--------|------|
| `온톨로지` / `온톨로지끝` | 온톨로지 블록 시작/종료 |
| `개념` / `개념끝` | 클래스(개념) 정의 블록 |
| `속성` | 클래스 속성 선언 |
| `관계` | 관계 타입 정의 |
| `질의` | 온톨로지 질의 실행 |
| `추론` / `추론끝` | 추론기 실행 블록 |
| `민감` | 속성 민감 지정 (학습 차단) |
| `익명화` | 속성 익명화 지정 (저장 시 마스킹) |
| `이어받기` | 개념 상속 선언 |

### 33.5 학습 거버넌스 — 민감정보 3단계 강제

```
1단계 선언: 속성에 민감 / 익명화 태그
2단계 차단: kc_learn_filter() — 민감 속성 자동 제외
3단계 강제: 헌법 계약 시스템 연동 — 위반 시 즉시 중단 + 감사 로그
```

-----

*Kcode v20.0.0 — 문법 명세 최신화 (산업/안전/AI/온톨로지 섹션 추가)*
